
/*

GlueJS provides an integrated event and function handler across multiple devices and client-server-client environments.

GlueServer - Version 0.1.1 (beta).
Developed by Luke Cohen.

Version 0.1.2:

- added optional object storage in LevelDB
- new objects are now automatically initialised with {} on registerAllowedObject
- removed deprecated functions
- centralised object loading and saving to dedicated functions
- tidied up the code

Node dependencies:

- Sha1 - npm install sha1 - obligatory
- LevelDB - npm install levelup leveldown - required if using LevelDB for object storage

*/

'use strict';

var GlueServer = function() {


  /* internal variables and objects */

  this.allowedServerFunctions = {};
  this.allowedFunctions = {};
  this.allowedServerEvents = [];
  this.allowedEvents = {};
  this.allowedObjects = {};
  this.restrictedObjects = {};
  this.subscribedClients = {};
  this.objects = [];
  this.sessionKey = "";
  this.persistEnabled = false;
  this.levelDbName = "glueServerDB";
  this.sha1 = "";
  this.initialised = false;

  var levelup, db, dbSet;
  var cons = true;

  var objectUpdateQueue = new Array();

  dbSet = false;

  /* / */


  /* gets the object ready to receive events & functions */
  this.init = function(enablePersist, dbName) {
    cons && console.log('init');

    /* create a unique key for this session */
    this.sessionKey = generateUUID();

    /* set persistanceEnabled - default is false */
    if (enablePersist && typeof enablePersist === 'boolean') {

      this.persistEnabled = enablePersist;

      if (dbName && isRelName(dbName)) {
        this.levelDbName = dbName;
      }

      this.initDB();

    }

    /* processes object save queue every five seconds - DEPRECATED: this is now handled on demand by this.updateObject() function
    if (this.persistEnabled === true) {

      var that = this;

      setInterval(function() {
        cons && console.log('2.5sec queue save tick');

        var dbStatus = db._status;

        if (dbStatus === "open") {
          that.saveQueuedObjects();
        }

      }, 2500);

    }*/

    return true;

  };


  /*

  Readies the LevelDB if required - LevelDB is a light-weight key/pair database created by Google. For more information on LevelDB, see http://leveldb.org/.

  The data layer interaction is set up in such a way that it could easily be swapped out for redis, BerkeleyDB, memcached or whichever key/pair storage engine works for the individual project.

  LevelDB is the default because it's widely supported, embedded in Javascript instead of running as a separate server, is very fast and lightweight, is developed by Google, and is well-documented and maintained.

  */
  this.initDB = function() {
    cons && console.log('initDB');

    if (this.persistEnabled === true) {

      var that = this;

      levelup = require('levelup');
      db = levelup('./' + this.levelDbName, {encoding: 'json', createIfMissing: true}, function (err, db) {

        if (err) {
          return console.log('level db error', err);
        } else {

          if (db._status == "open") {
            dbSet = true;
            cons && console.log("dbSet", dbSet);
          }

        }

      });

    } else {

      return false;

    }

  };


  /* checks objectUpdateQueue and saves changes to DB if appropriate */
  this.saveQueuedObjects = function() {
    console.log('saveQueuedObjects');

    var dbStatus = db._status;

    if (objectUpdateQueue && dbStatus == "open") {

      for (var i = 0; i < objectUpdateQueue.length; i++) {

        if (objectUpdateQueue[i]) {

          cons && console.log('persisting queue item ' + i + ' to data layer:', objectUpdateQueue[i]);

          var objNameHash = this.sha1(objectUpdateQueue[i]);
          this.dbPut(objectUpdateQueue[i], this.objects[objNameHash]);

          delete objectUpdateQueue[i];

        }

      }

    }

  };


  /* dbPut wraps level.put for error handling etc */
  this.dbPut = function(keyToPut, valueToPut) {
    cons && console.log('dbPut', keyToPut, valueToPut);

    var that = this;

    this.dbCan(keyToPut, function() {

      if (typeof valueToPut === 'object') {
        valueToPut = JSON.stringify(valueToPut);
      }

      db.put(keyToPut, valueToPut, function(err) {
        if (err) {

          cons && console.log('db.put error', err);
          return false;

        } else {

          cons && console.log('db.put success');

        }
      });

    });

  };


  /* dbGet wraps level.get for error handling etc */
  this.dbGet = function(keyToGet, callback) {
    cons && console.log('dbGet', keyToGet);

    db.get(keyToGet, function(err, value) {

      if (err) {

        cons && console.log('db.get error', err);
        return false;

      } else {

        if (checkStringJSON(value) === true) {
          value = JSON.parse(value);
        }

        return value;

      }

    });

  };


  /* updates an in-memory object to match the stored object */
  this.objSetFromData = function(keyToGet, objToSet, that) {
    cons && console.log('objSetFromData', keyToGet, objToSet);

    db.get(keyToGet, function(err, value) {
      cons && console.log('value', value);

      if (err) {

        cons && console.log('db.get error', err);

        if (err.toString().trim().substring(0, 13) == "NotFoundError") {

          /* object doesn't exist in datastore, so create an empty one */

          cons && console.log('object not in data layer, creating empty object ' + keyToGet);

          that.objects[objToSet] = {};
          objectUpdateQueue.push(keyToGet);
          that.saveQueuedObjects();

          return true;

        }

        return false;

      } else {

        if (checkStringJSON(value) === true) {
          value = JSON.parse(value);
        }

        that.objects[objToSet] = value;

        cons && console.log('objects[' + objToSet + ']', that.objects[objToSet]);

        return true;

      }

    });

  }


  /* dbDel wraps level.get for error handling etc */
  this.dbDel = function(keyToDel) {
    cons && console.log('dbDel', keyToDel);

    this.dbCan(keyToDel, function() {

      cons && console.log('db deleting');

      db.del(keyToDel, function(err) {

        if (err) {
          cons && console.log('db.del error', err);
          return false;
        }

      });

    });

  };


  /* dbCan returns a simple boolean against all the persistent storage availability checks */
  this.dbCan = function(optObjName, callback) {
    cons && console.log('dbCan', optObjName);

    if (this.persistEnabled === false) {
      cons && console.log('persist not enabled');
      return false;
    }

    if (optObjName) {
      if (!isRelName(optObjName) || !this.allowedObjects[optObjName] || this.allowedObjects[optObjName].persist === false) {

        cons && console.log('invalid object name');
        return false;

      }
    }

    var dbStatus = db._status;

    var goAhead = function(callback) {
      cons && console.log("dbCan.goAhead");
      callback();
    };

    switch (dbStatus) {

      case "open":
        goAhead(callback);
      break;

      case "opening":

        /* wait five seconds */
        setTimeout(function() {

          var dbStatus = db._status;

          if (dbStatus === "open") {
            goAhead(callback);
          } else {
            return false;
          }

        }, 5000);

      break;

    };

  };


  /* adds an object to the allowedObjects list */
  this.registerAllowedObject = function(objectName, readWriteOnly, persist) {
    cons && console.log('registerAllowedObject', objectName, readWriteOnly, persist);

    var objectNameHash = this.sha1(objectName);

    if (!this.allowedObjects[objectName]) {

      var newObject = {};
      newObject.objectRW = (readWriteOnly) || false;
      newObject.persist = (persist) || false;

      this.allowedObjects[objectName] = newObject;

      if (this.persistEnabled === true) {

        if (dbSet === true) {

          /* load object from data layer */
          this.objSetFromData(objectName, objectNameHash, this);

        } else {

          var that = this;

          /* wait five seconds and try again */
          setTimeout(function() {

            var dbStatus = db._status;

            if (dbStatus === "open") {

              /* load object from data layer */
              that.objSetFromData(objectName, objectNameHash, that);

            } else {
              return false;
            }

          }, 5000);

        }


      } else {

        var newObj = {};
        this.updateObject(objectName, newObj);

      }

    } else {

      cons && console.log('object already registered');
      return false;

    }

  };


  /* de-registers an allowed object */
  this.deRegisterAllowedObject = function(objectName) {
    cons && console.log('deRegisterAllowedObject', objectName);

    if (allowedObjects.indexOf(objectName) > -1) {
      allowedObjects.splice(allowedObjects.indexOf(objectName));
    }

  };


  /* adds a function to the allowedFunctions or allowedRemoteFunctions list */
  this.registerAllowedFunction = function(functionName, serverOrGeneral) {
    cons && console.log('registerAllowedFunction', functionName, serverOrGeneral);

    switch(serverOrGeneral) {

      case "general":

        if (!this.allowedFunctions[functionName]) {
          this.allowedFunctions[functionName] = {};
        }

      break;

      case "server":

        if (!this.allowedServerFunctions[functionName]) {
          this.allowedServerFunctions[functionName] = {};
        }

      break;

    }

  };


  /* removes a function from the allowedFunctions or allowedRemoteFunctions list */
  this.deregisterAllowedFunction = function(functionName, remoteOrGeneral) {
    cons && console.log('deregisterAllowedFunction', functionName, remoteOrGeneral);

    switch(remoteOrGeneral) {

      case "general":

        if (allowedFunctions.indexOf(functionName) > -1) {
          allowedFunctions.splice(index, 1);
        }

      break;

      case "remote":

        if (allowedServerFunctions.indexOf(functionName) > -1) {
          allowedRemoteFunctions.splice(index, 1);
        }

      break;

    }

  };


  /* adds an event to the allowedEvents or allowedServerEvents list */
  this.registerAllowedEvent = function(eventName, remoteOrGeneral) {
    cons && console.log('registerAllowedEvent', eventName, remoteOrGeneral);

    switch(remoteOrGeneral) {

      case "general":

        if (!this.allowedEvents[eventName]) {
          this.allowedEvents[eventName] = {};
        }

      break;

      case "remote":

        if (!this.allowedServerEvents[eventName]) {
          this.allowedServerEvents[eventName] = {};
        }

      break;

    }

  };


  /* removes an event from the allowedEvents or allowedServerEvents list */
  this.deregisterAllowedEvent = function(eventName, remoteOrGeneral) {
    cons && console.log('deregisterAllowedEvent', eventName, remoteOrGeneral);

    switch(remoteOrGeneral) {

      case "general":

        if (allowedEvents.indexOf(eventName) > -1) {
          allowedEvents.splice(index, 1);
        }

      break;

      case "remote":

        if (allowedServerEvents.indexOf(eventName) > -1) {
          allowedServerEvents.splice(index, 1);
        }

      break;

    }

  };


  /* return allowedFunctions */
  this.listAllowedFunctions = function(remoteOrGeneral) {
    cons && console.log('listAllowedFunctions', remoteOrGeneral);

    switch(remoteOrGeneral) {
      case "remote":
        return this.allowedServerFunctions;
      break;

      case "general":
        return this.allowedFunctions;
      break;
    }

  };


  /* fetches the latest version of an object */
  this.fetchObject = function(objectName) {
    cons && console.log('fetchObject', objectName);

    if (objectName && typeof objectName === 'string' && isRelName(objectName) && this.allowedObjects[objectName]) {

      var objNameHash = this.sha1(objectName);
      var objToReturn = this.objects[objNameHash];

      if (typeof objToReturn !== 'object' && checkStringJSON(objToReturn)) {
        objToReturn = JSON.parse(objToReturn);
      }

      return objToReturn;

    } else {

      cons && console.log("incorrect objectName or newObject passed, or object is not registered on server");
      return false;

    }

  };


  /* 'objectSplice' simulates the .splice() function, cutting up the object as requested */
  this.objectSplice = function(objectName, index, howmany) {
    cons && console.log('objectSplice', index, howmany);

    if (this.allowedObjects[objectName] && typeof index === 'number' && typeof howmany === 'number') {

      var obj = this.allowedObjects[objectName];
      var objectNameHash = this.sha1(objectName);

      if (obj.objectRW === false) {

        var theObject = this.fetchObject(objectName);
        theObject.splice(objectToAppend, index, howmany);

        this.updateObject(objectName, theObject);

        return true;

      } else {
        console.log('object is read-only');
        return false;
      }

    } else {
      return false;
    }

  };


  /* 'listAppend' is a simpler version of objectAppend - where the object we're appending to is a flat JSON list rather than an object containing objects */
  this.listAppend = function(objectName, itemToAppend) {
    cons && console.log('listAppend', objectName, itemToAppend);

    /* TO-DO */

  }


  /* 'objectAppend' simulates the .push() function, adding an object an existing object */
  this.objectAppend = function(objectName, objectToAppend) {
    cons && console.log('objectAppend', objectName, objectToAppend);

    var obj = this.allowedObjects[objectName];
    var curObject = this.fetchObject(objectName);

    console.log('curObject', curObject)

    if (obj && obj.objectRW === false) {

      /* generate GUID for the new object */
      var newObjGUID = generateUUID();
      objectToAppend._glueGUID = newObjGUID;

      /* add new object to end of existing object */
      if (!Object.keys(curObject).length) {
        curObject[0] = objectToAppend;
      } else {
        curObject[Object.keys(curObject).length] = objectToAppend;
      }

      this.updateObject(objectName, curObject);
      return true;

    } else {

      return false;

    }

  };


  /* updates the object, if it isn't read-only */
  this.updateObject = function(objectName, newObject) {
    cons && console.log('updateObject', objectName);

    if (isRelName(objectName) && this.allowedObjects[objectName] && this.allowedObjects[objectName].objectRW === false && isRelObject(newObject, false)) {

      var objNameHash = this.sha1(objectName);
      this.objects[objNameHash] = newObject;

      if (this.persistEnabled === true) {
        objectUpdateQueue.push(objectName);
        this.saveQueuedObjects();
      }

      return true;

    } else {

      cons && console.log("incorrect objectName or newObject passed, or object is not registered on server");
      return false;

    }

  };


  /* updates a specific node in an object */
  this.updateObjectNode = function(objectName, nodeIndex, newObject) {
    cons && console.log("updateObjectNode", objectName, nodeIndex, newObject);

    var objectNameHash = this.sha1(objectName);

    if (this.allowedObjects[objectName] && this.objects[objectNameHash][nodeIndex] && this.allowedObjects[objectName].objectRW === false) {

      if (checkStringJSON(newObject) === true) {
        newObject = JSON.parse(newObject);
      }

      this.objects[objectNameHash][nodeIndex] = newObject;
      this.updateObject(objectName, this.objects[objectNameHash]);

      return true;

    } else {
      return false;
    }

  };


  /* notifies an append to an object */
  this.broadcastAppend = function(objectName, objectAddition, ioObj, socketObj) {
    cons && console.log('broadcastAppend', objectName, objectAddition);

    var msg = {
      "messageType" : "objectAppend",
      "objectName" : objectName,
      "objectAddition" : objectAddition
    };

    socketObj.broadcast.emit('glue message', msg);
    socketObj.emit('glue message', msg);

  };


  /* notifies an object splice */
  this.broadcastSplice = function(objectName, spliceIndex, spliceHowMany, ioObj, socketObj) {
    cons && console.log('broadcastSplice', objectName, spliceIndex, spliceHowMany);

    var msg = {
      "messageType" : "objectSplice",
      "spliceIndex" : spliceIndex,
      "spliceHowMany" : spliceHowMany
    };

    socketObj.broadcast.emit('glue message', msg);
    socketObj.emit('glue message', msg);

  };


  /* sends out an updated object to all connected clients */
  this.broadcastObjectUpdate = function(objectName, ioObj, socketObj) {
    cons && console.log('broadcastObjectUpdate', objectName);

    if (this.allowedObjects[objectName]) {

      var objectNameHash = this.sha1(objectName);
      var theObject = this.fetchObject(objectName);

      var msg = {
        "messageType": "objectUpdate",
        "objectName": objectName,
        "newObject": theObject
      };

      msg.object = theObject;

      socketObj.broadcast.emit('glue message', msg);
      socketObj.emit('glue message', msg);

    } else {
      return false;
    }

  };


  /* broadcasts an update notification on a specific object node */
  this.broadcastObjectNodeUpdate = function(objectName, nodeIndex, ioObj, socketObj) {
    cons && console.log('broadcastObjectNodeUpdate', objectName, nodeIndex);

    if (this.allowedObjects[objectName]) {

      var objectNameHash = this.sha1(objectName);
      var updatedNode = this.objects[objectNameHash][nodeIndex];

      var msg = {
        "messageType": "objectNodeUpdate",
        "objectName": objectName,
        "nodeIndex": nodeIndex
      };

      msg.updatedNodeObject = updatedNode;

      socketObj.broadcast.emit('glue message', msg);
      socketObj.emit('glue message', msg);

    } else {
      return false;
    }

  };


  /* creates a lock on an object if it isn't already locked */
  this.lockObject = function(objectName) {
    cons && console.log("lockObject", objectName);

    if (isRelName(objectName) && this.allowedObjects[objectName]) {

      var obj = this.allowedObjects[objectName];

      if (obj.locked === true) {

        var msg = {
          "messageType": "lockFail",
          "objectName": objectName
        };

        socketObj.emit('glue message', msg);

        return false;

      } else {

        var newLockToken = generateUUID();

        obj.locked = true;
        obj.lockToken = newLockToken;

        var msg = {
          "messageType": "lockSuccess",
          "objectName": objectName,
          "lockToken": newLockToken
        };

        socketObj.emit('glue message', msg);

        return true;

      }

    } else {
      return false;
    }

  }
  /* / */


  /* release an object lock, if the lockToken provided is associated with a lock */
  var unlockObject = function(objectName, lockToken) {
    cons && console.log("unlockObject", objectName, lockToken);



  }
  /* / */


  /* generate error message JSON */
  this.errorMessage = function(errorMessage) {

    var msg = {
      "messageType" : "error",
      "errorMessage" : errorMessage
    };

    return msg;

  };


  /* triggers relevant functions depending on the socket message received */
  this.signalHandler = function(message, ioObj, socketObj) {
    cons && console.log("signalHandler messageType:", message.messageType);

    if (checkStringJSON(message)) {
      message = JSON.parse(message);
    }

    switch(message.messageType) {


      case 'triggerEvent':

        var eventName = message.eventName;
        var eventParams = message.eventParams;

        if (this.allowedEvents[triggerName]) {

          var msg = {
            "messageType": "eventTriggered",
            "eventName": eventName,
            "eventParams": eventParams
          };

          socketObj.broadcast.emit('glue message', msg);
          socketObj.emit('glue message', msg);

        } else {

          socketObj.emit('glue message', this.errorMessage("event not registered at server"));

          return false;

        }

      break;


      case 'triggerFunction':
        cons && console.log('triggerFunction', message.functionName);

        var functionName = message.functionName;
        var functionParams = message.functionParams;

        /* TODO: run the function here on the server first, if it exists */

        if (this.allowedFunctions[functionName]) {

          cons && console.log('sending general function call');

          var msg = {
            "messageType" : "functionTriggered",
            "functionName" : functionName,
            "functionParams" : functionParams
          };

          socketObj.broadcast.emit('glue message', msg);
          socketObj.emit('glue message', msg);

        } else {

          cons && console.log('function not registered at server');

          socketObj.emit('glue message', this.errorMessage("function not registered at server"));
          return false;

        }

      break;


      case 'registerObject':

        var objectName = message.objectName;

        if (isRelName(objectName) && !this.allowedObjects[objectName] && !this.restrictedObjects[objectName]) {

          this.registerAllowedObject(objectName, false);

        } else {

          cons && console.log('invalid objectName or object already registered on server');
          return false;

        }

      break;


      case 'serverFunction':

        /* trigger a function on the server */

        var functionName = message.functionName;
        var functionParams = message.functionParams;

        if (this.allowedServerFunctions[functionName]) {

          var retn = global[functionName](functionParams);
          console.log('retn', retn);

          return false;

        } else {

          cons && console.log('server function not registered');

          socketObj.emit('glue message', this.errorMessage("server function not registered"));
          return false;

        }

      break;


      case 'serverEvent':

        /* trigger an event on the server */

      break;


      case 'fetchObject':

        var objectName = message.object.objectName;
        var objectNameHash = this.sha1(objectName);

        if (this.allowedObjects[objectName]) {

          var msg = {
            "messageType" : "loadedObject",
            "objectName" : objectName
          };

          var objToReturn = this.fetchObject(objectName);
          msg.object = objToReturn;

          cons && console.log("object '" + objectName + "' to return", objToReturn);

          socketObj.emit('glue message', msg);

        } else {

          cons && console.log('attempted fetchObject on non-allowed or unregistered object', objectName);
          return false;

        }

      break;


      case 'objectAppend':

        var objectName = message.object.objectName;
        var objectAddition = message.objectAddition;

        if (this.objectAppend(objectName, objectAddition) === true) {
          this.broadcastAppend(objectName, objectAddition, ioObj, socketObj);
        }

      break;


      case "objectItemDelete":

        var objectName = message.objectName;
        var itemToDelete = message.itemToDelete;
        var isIndex = message.isIndex;

        var obj = this.fetchObject(objectName);

        if (obj[itemToDelete]) {
          delete obj[itemToDelete];
        }

        this.updateObject(objectName, obj);

        var msg = {
          "messageType" : "objectItemDelete",
          "objectName" : objectName,
          "itemToDelete" : itemToDelete,
          "isIndex" : isIndex
        };

        msg.itemToDelete = itemToDelete;

        socketObj.broadcast.emit('glue message', msg);
        socketObj.emit('glue message', msg);

      break;


      case 'updateObject':

        var objectName = message.objectName;
        var newObject = message.newObject;

        if (this.updateObject(objectName, newObject) === true) {
          this.broadcastObjectUpdate(objectName, ioObj, socketObj);
        }

      break;


      case 'updateObjectNode':

        var objectName = message.objectName;
        var nodeIndex = message.nodeIndex;
        var newObject = message.newObject;

        if (isRelName(objectName) && typeof nodeIndex === 'number' && isRelObject(newObject)) {

          if (this.updateObjectNode(objectName, nodeIndex, newObject) === true) {
            this.broadcastObjectNodeUpdate(objectName, nodeIndex, ioObj, socketObj);
          }

        } else {
          return false;
        }

      break;


      case 'lockRequest':

        var objectName = message.objectName;
        this.lockObject(objectName);

      break;


      case 'lockRelease':

        var objectName = message.objectName;
        var lockToken = message.lockToken;

        this.unlockObject(objectName, lockToken);

      break;


    }

  };


  /* helper functions */
  var isRelName = function(nameToCheck) {

    if (nameToCheck && typeof nameToCheck === 'string' && /^([a-zA-Z0-9_-]+)$/i.test(nameToCheck) === true) {
      return true;
    } else {
      return false;
    }

  };


  var checkStringJSON = function(jsonToTest) {

    if (jsonToTest && typeof jsonToTest === 'string') {

      try {
        JSON.parse(jsonToTest);
        return true;
      } catch(e) {
        return false;
      }

    } else {
      return false;
    }

  };


  var isRelObject = function(objectToTest, jsonStringTest) {

    if (objectToTest && typeof objectToTest === 'object') {
      return true;
    } else {

      if (jsonStringTest && jsonStringTest === true) {
        return checkStringJSON(objectToTest);
      } else {
        return false;
      }

    }

  };


  var extend = function(obj, src) {

    for (var key in src) {
        if (src.hasOwnProperty(key)) obj[key] = src[key];
    }

    return obj;

  };


  var generateUUID = function(){

    var d = new Date().getTime();

    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });

    return uuid;

  };

};

var exports = module.exports = GlueServer;
